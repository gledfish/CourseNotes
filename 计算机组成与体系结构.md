
# 计算机组成与系统结构

## 绪论

**摩尔定律** : 集成电路芯片的集成度每 18 个月翻一番

**冯 · 诺依曼 计算机结构**
P5 图
**软件系统**

* 系统软件
* 应用软件

**计算机的层次结构**
P7图

**计算机系统性能计算**

**执行时间**：计算机完成一个任务所用的总时间

**吞吐量**：在给定时间内（并行）完成的总任务数
$$
性能P = \frac 1{执行时间}
$$
**Amdahl定律**：计算机系统中某一个部件提高后，整个计算机系统的提高与该部件的使用频率有关
$$
加 速 比 = \frac{改 进 前 的 系 统 总 执 行 时 间} {改 进 后 的 系 统 总 执 行 时 间}
$$

## 计算机系统中的数据表示
当代计算机大多都是以二进制为基础，就如同现实生活中的十进制。
计算机中的整数包括数字位（存储数值）和字符位（表示正负）
**有符号数**：数字位前有一位用来表示符号，0 表示正，1 表示负

**无符号数**：数中的每一位都用来表示数值

**定点数**：小数点的位置固定不变

 **浮点数**：小数点的位置不固定

**原码**：十进制数的二进制表示

整数原码：
$$
[X]_原 =\begin{cases}
X &0 \le X < 2^{n-1}\\
2^{n-1} - X & -2^{n-1}<X\le0
\end{cases}
$$

小数原码：
$$
[X]_原 = \begin{cases}
X &0 \le X < 1 \\
1-X &-1 < X \le 0
\end{cases}
$$
**补码**
原码不适合运算，这时候补码就派上了用场。
$$
[X]_原 =\begin{cases}
X &0 \le X < 2^{n-1}\\
2^n + X & -2^{n-1}\le X < 0
\end{cases}
$$

$$
[X]_原 = \begin{cases}
X &0 \le X < 1 \\
2+X &-1 \le X < 0
\end{cases}
$$

**补码实现加减法运算**
$$
[X+Y]_补=[X]_补+[Y]_补
$$
$$
\begin{aligned}
{[X-Y]_补 } & =[X]_补+[-Y] _补\\
& =[X]_补+[[Y]_补]_补
\end{aligned}
$$
补码还有其他特殊的用处，在后文会提到。
**反码**
反码是介于补码和原码之间的一种过渡码字
整数反码
$$
[X]_反= \begin{cases}X & 0 \leq X<2^{n-1} \\ 2^n-1+X &-2^{n-1}<X \leq 0\end{cases}
$$
小数反码
$$
[X]_反 = \begin{cases} X &0 \le X  < 1 \\2 - 2 ^{-n+1} + X &-1 < X \le 0
                \end{cases}
$$

**移码**
 移码解决了补码之间比较大小不直观的问题
移码 = 补码 + 偏移量
移码多用于浮点数中表示阶码，均为整数，定点整数的移码表示：
$$
[X]_移=2^{n-1} + X  
$$
求整数的移码可以使用定义，也可以先求出该数的补码，然后将符号位取反。
**不同编码的对比**
* 原码表示更直观，用于乘除运算更方便
* 
* 正数的原码，反码，补码都相同
* 补码中 0 的表示是唯一的
### 浮点数
浮点数的表示不同于整数只需要存储数值位和符号位，浮点数需要保存更多的信息
**浮点数的表示**：$$
F=M \times R^E
$$
* M表示尾数
* E表示阶码
* R表示基数

阶码是整数，阶码的位数决定浮点数的数值范围
阶符决定阶码的正负
尾数的位数决定浮点数的精度
尾数的尾符表示尾数的符号
浮点数可以分为
* 规格化浮点数：尾数的绝对值在1 / 2 ~ 1 之间
* 非规格化浮点数

规格化尾数可以表示更多的有效数字
**定点数和浮点数的比较
* 当表示数据的位数相同时，浮点数的表示范围比定点数大的多。
* 浮点数为规格化数时，精度远比定点数高
* 浮点数的运算比定点数运算步骤多，速度比定点数低，运算电路更复杂

**IEEE-754标准
该标准规定了浮点数的存储细节等，如各个存储单元要保存多少bit...
P30 图

### 其他数值编码

**有权码**：在不同数位上赋予不同的权值
如：**8424BCD**码 在四位二进制上从高到低依次表示8，4，2，1。这样只需 4 位二进制即可表示一个 10进制编码，如：
* 16：0001  0110
* 34：0011  0100
* 87：1000  0111

**无权码**：各位没有不同的权值

如**余 3 码** ：在每 8421BCD 的基础上加上 0011.
如**格雷码**：
### 非数值编码
除了对数字编码，我们还需要对文本，声音，图像等信息编码，这里介绍对文本信息进行编码。
**ASCII码**：美国信息交换的一种标准，已成为国际通用的信息交换标准代码，该字符系统采用 7 位 二进制位（一个字节，最高一位为 0）对字符进行编码，这些字符包括数字，英文字母，特殊符号以及一些特殊指令。

### 检错与纠错码

## 运算方法与运算器
**补码加法**
对数值的加减运算可以用任何一种编码来实现，但用的最多最普遍的是补码
补码加法：
$$
[X+Y]_补=[X]_补+[Y]_补
$$

eg：利用补码加法求 63 + 35 = ？
$$
\begin{aligned}
 63_补 &= 00111111\\
 35_补 &= 00100011\\
 [63 + 35]_补 &= 01100010
\end{aligned}
$$
**补码减法**
$$
[X-Y]_补=[X]_补+[[Y]_补]_{求补}
$$
求补：所有位取反，末位加一。补码可以正负数的互相转换
负数补码：符号位除外，其他位按位取反，末尾加一。

eg:利用补码减法计算 63 - 35 = ？
$$
\begin{aligned}
 63_补 &= 00111111\\
 (-35)_补 &= ((35)_补)_{求补}\\
 35_补 &= 00100011\\
 [63 - 35]_补 &= 00011100
\end{aligned}
$$
**溢出判断**
溢出：同符号数相加（减）可能发生溢出
判断溢出的方法：
1. 双符号位：使用两位表示符号，00表示正号，11表示负号。如果运算结果中两个符号位不一致，则发生了溢出。
2. 进位判别法：设 C_n-1 表示数值位向符号位的进位，C_n 表示符号位向前一位的进位。
**BCD加法器**
eg：计算 BCD 数加法
P55 3.8
BCD码加法的校正：每四位的计算结果如果大于 9，则结果加0110。

**原码一位乘法**
法则：
* 符号为 乘数的符号位和被乘数的符号位相异或
* 数值为 乘数的绝对值与被乘数的绝对值的乘积

**补码一位乘法**
布斯乘法法则
(全文完)
(本文不定时更新)

以上内容只代表个人观点，如果对你有所帮助，[点击这里给我一个小小的star](https://github.com/gledfish/blog)

如果有任何问题欢迎随时联系我进行批评指正：2076577077@qq.com  

我是gled fish, [点击这里来到我的博客网站：](https://gledfish.netlify.app/)
---

---

尊重作者原创, 转载请注明作者和出处，请勿用于任何商业用途。